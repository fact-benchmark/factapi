// Code generated by Prisma (prisma@1.26.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  agent: (where?: AgentWhereInput) => Promise<boolean>;
  annotation: (where?: AnnotationWhereInput) => Promise<boolean>;
  attribution: (where?: AttributionWhereInput) => Promise<boolean>;
  checkWorthy: (where?: CheckWorthyWhereInput) => Promise<boolean>;
  claim: (where?: ClaimWhereInput) => Promise<boolean>;
  claimSupport: (where?: ClaimSupportWhereInput) => Promise<boolean>;
  content: (where?: ContentWhereInput) => Promise<boolean>;
  response: (where?: ResponseWhereInput) => Promise<boolean>;
  truthRating: (where?: TruthRatingWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  agent: (where: AgentWhereUniqueInput) => AgentPromise;
  agents: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Agent>;
  agentsConnection: (args?: {
    where?: AgentWhereInput;
    orderBy?: AgentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AgentConnectionPromise;
  annotations: (args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Annotation>;
  annotationsConnection: (args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnnotationConnectionPromise;
  attributions: (args?: {
    where?: AttributionWhereInput;
    orderBy?: AttributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Attribution>;
  attributionsConnection: (args?: {
    where?: AttributionWhereInput;
    orderBy?: AttributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AttributionConnectionPromise;
  checkWorthies: (args?: {
    where?: CheckWorthyWhereInput;
    orderBy?: CheckWorthyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CheckWorthy>;
  checkWorthiesConnection: (args?: {
    where?: CheckWorthyWhereInput;
    orderBy?: CheckWorthyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CheckWorthyConnectionPromise;
  claim: (where: ClaimWhereUniqueInput) => ClaimPromise;
  claims: (args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Claim>;
  claimsConnection: (args?: {
    where?: ClaimWhereInput;
    orderBy?: ClaimOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClaimConnectionPromise;
  claimSupports: (args?: {
    where?: ClaimSupportWhereInput;
    orderBy?: ClaimSupportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ClaimSupport>;
  claimSupportsConnection: (args?: {
    where?: ClaimSupportWhereInput;
    orderBy?: ClaimSupportOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClaimSupportConnectionPromise;
  contents: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Content>;
  contentsConnection: (args?: {
    where?: ContentWhereInput;
    orderBy?: ContentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ContentConnectionPromise;
  responses: (args?: {
    where?: ResponseWhereInput;
    orderBy?: ResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Response>;
  responsesConnection: (args?: {
    where?: ResponseWhereInput;
    orderBy?: ResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ResponseConnectionPromise;
  truthRatings: (args?: {
    where?: TruthRatingWhereInput;
    orderBy?: TruthRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TruthRating>;
  truthRatingsConnection: (args?: {
    where?: TruthRatingWhereInput;
    orderBy?: TruthRatingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TruthRatingConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAgent: (data: AgentCreateInput) => AgentPromise;
  updateAgent: (args: {
    data: AgentUpdateInput;
    where: AgentWhereUniqueInput;
  }) => AgentPromise;
  updateManyAgents: (args: {
    data: AgentUpdateManyMutationInput;
    where?: AgentWhereInput;
  }) => BatchPayloadPromise;
  upsertAgent: (args: {
    where: AgentWhereUniqueInput;
    create: AgentCreateInput;
    update: AgentUpdateInput;
  }) => AgentPromise;
  deleteAgent: (where: AgentWhereUniqueInput) => AgentPromise;
  deleteManyAgents: (where?: AgentWhereInput) => BatchPayloadPromise;
  createAnnotation: (data: AnnotationCreateInput) => AnnotationPromise;
  updateManyAnnotations: (args: {
    data: AnnotationUpdateManyMutationInput;
    where?: AnnotationWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAnnotations: (where?: AnnotationWhereInput) => BatchPayloadPromise;
  createAttribution: (data: AttributionCreateInput) => AttributionPromise;
  updateManyAttributions: (args: {
    data: AttributionUpdateManyMutationInput;
    where?: AttributionWhereInput;
  }) => BatchPayloadPromise;
  deleteManyAttributions: (
    where?: AttributionWhereInput
  ) => BatchPayloadPromise;
  createCheckWorthy: (data: CheckWorthyCreateInput) => CheckWorthyPromise;
  updateManyCheckWorthies: (args: {
    data: CheckWorthyUpdateManyMutationInput;
    where?: CheckWorthyWhereInput;
  }) => BatchPayloadPromise;
  deleteManyCheckWorthies: (
    where?: CheckWorthyWhereInput
  ) => BatchPayloadPromise;
  createClaim: (data: ClaimCreateInput) => ClaimPromise;
  updateClaim: (args: {
    data: ClaimUpdateInput;
    where: ClaimWhereUniqueInput;
  }) => ClaimPromise;
  updateManyClaims: (args: {
    data: ClaimUpdateManyMutationInput;
    where?: ClaimWhereInput;
  }) => BatchPayloadPromise;
  upsertClaim: (args: {
    where: ClaimWhereUniqueInput;
    create: ClaimCreateInput;
    update: ClaimUpdateInput;
  }) => ClaimPromise;
  deleteClaim: (where: ClaimWhereUniqueInput) => ClaimPromise;
  deleteManyClaims: (where?: ClaimWhereInput) => BatchPayloadPromise;
  createClaimSupport: (data: ClaimSupportCreateInput) => ClaimSupportPromise;
  deleteManyClaimSupports: (
    where?: ClaimSupportWhereInput
  ) => BatchPayloadPromise;
  createContent: (data: ContentCreateInput) => ContentPromise;
  updateManyContents: (args: {
    data: ContentUpdateManyMutationInput;
    where?: ContentWhereInput;
  }) => BatchPayloadPromise;
  deleteManyContents: (where?: ContentWhereInput) => BatchPayloadPromise;
  createResponse: (data: ResponseCreateInput) => ResponsePromise;
  updateManyResponses: (args: {
    data: ResponseUpdateManyMutationInput;
    where?: ResponseWhereInput;
  }) => BatchPayloadPromise;
  deleteManyResponses: (where?: ResponseWhereInput) => BatchPayloadPromise;
  createTruthRating: (data: TruthRatingCreateInput) => TruthRatingPromise;
  updateManyTruthRatings: (args: {
    data: TruthRatingUpdateManyMutationInput;
    where?: TruthRatingWhereInput;
  }) => BatchPayloadPromise;
  deleteManyTruthRatings: (
    where?: TruthRatingWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  agent: (
    where?: AgentSubscriptionWhereInput
  ) => AgentSubscriptionPayloadSubscription;
  annotation: (
    where?: AnnotationSubscriptionWhereInput
  ) => AnnotationSubscriptionPayloadSubscription;
  attribution: (
    where?: AttributionSubscriptionWhereInput
  ) => AttributionSubscriptionPayloadSubscription;
  checkWorthy: (
    where?: CheckWorthySubscriptionWhereInput
  ) => CheckWorthySubscriptionPayloadSubscription;
  claim: (
    where?: ClaimSubscriptionWhereInput
  ) => ClaimSubscriptionPayloadSubscription;
  claimSupport: (
    where?: ClaimSupportSubscriptionWhereInput
  ) => ClaimSupportSubscriptionPayloadSubscription;
  content: (
    where?: ContentSubscriptionWhereInput
  ) => ContentSubscriptionPayloadSubscription;
  response: (
    where?: ResponseSubscriptionWhereInput
  ) => ResponseSubscriptionPayloadSubscription;
  truthRating: (
    where?: TruthRatingSubscriptionWhereInput
  ) => TruthRatingSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AgentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnnotationOrderByInput =
  | "source_url_ASC"
  | "source_url_DESC"
  | "data_ASC"
  | "data_DESC"
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AttributionOrderByInput =
  | "source_url_ASC"
  | "source_url_DESC"
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CheckWorthyOrderByInput =
  | "call_ASC"
  | "call_DESC"
  | "check_worthiness_ASC"
  | "check_worthiness_DESC"
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClaimOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "claim_text_ASC"
  | "claim_text_DESC"
  | "claim_timestamp_ASC"
  | "claim_timestamp_DESC"
  | "created_ASC"
  | "created_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ClaimSupportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContentOrderByInput =
  | "hash_ASC"
  | "hash_DESC"
  | "mime_type_ASC"
  | "mime_type_DESC"
  | "data_ASC"
  | "data_DESC"
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResponseOrderByInput =
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TruthRatingOrderByInput =
  | "call_ASC"
  | "call_DESC"
  | "truthiness_ASC"
  | "truthiness_DESC"
  | "created_ASC"
  | "created_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AgentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface AgentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: AgentWhereInput[] | AgentWhereInput;
  OR?: AgentWhereInput[] | AgentWhereInput;
  NOT?: AgentWhereInput[] | AgentWhereInput;
}

export interface AnnotationWhereInput {
  source_url?: String;
  source_url_not?: String;
  source_url_in?: String[] | String;
  source_url_not_in?: String[] | String;
  source_url_lt?: String;
  source_url_lte?: String;
  source_url_gt?: String;
  source_url_gte?: String;
  source_url_contains?: String;
  source_url_not_contains?: String;
  source_url_starts_with?: String;
  source_url_not_starts_with?: String;
  source_url_ends_with?: String;
  source_url_not_ends_with?: String;
  data?: String;
  data_not?: String;
  data_in?: String[] | String;
  data_not_in?: String[] | String;
  data_lt?: String;
  data_lte?: String;
  data_gt?: String;
  data_gte?: String;
  data_contains?: String;
  data_not_contains?: String;
  data_starts_with?: String;
  data_not_starts_with?: String;
  data_ends_with?: String;
  data_not_ends_with?: String;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: AnnotationWhereInput[] | AnnotationWhereInput;
  OR?: AnnotationWhereInput[] | AnnotationWhereInput;
  NOT?: AnnotationWhereInput[] | AnnotationWhereInput;
}

export interface AttributionWhereInput {
  source_url?: String;
  source_url_not?: String;
  source_url_in?: String[] | String;
  source_url_not_in?: String[] | String;
  source_url_lt?: String;
  source_url_lte?: String;
  source_url_gt?: String;
  source_url_gte?: String;
  source_url_contains?: String;
  source_url_not_contains?: String;
  source_url_starts_with?: String;
  source_url_not_starts_with?: String;
  source_url_ends_with?: String;
  source_url_not_ends_with?: String;
  snapshot?: ContentWhereInput;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: AttributionWhereInput[] | AttributionWhereInput;
  OR?: AttributionWhereInput[] | AttributionWhereInput;
  NOT?: AttributionWhereInput[] | AttributionWhereInput;
}

export interface ContentWhereInput {
  hash?: String;
  hash_not?: String;
  hash_in?: String[] | String;
  hash_not_in?: String[] | String;
  hash_lt?: String;
  hash_lte?: String;
  hash_gt?: String;
  hash_gte?: String;
  hash_contains?: String;
  hash_not_contains?: String;
  hash_starts_with?: String;
  hash_not_starts_with?: String;
  hash_ends_with?: String;
  hash_not_ends_with?: String;
  mime_type?: String;
  mime_type_not?: String;
  mime_type_in?: String[] | String;
  mime_type_not_in?: String[] | String;
  mime_type_lt?: String;
  mime_type_lte?: String;
  mime_type_gt?: String;
  mime_type_gte?: String;
  mime_type_contains?: String;
  mime_type_not_contains?: String;
  mime_type_starts_with?: String;
  mime_type_not_starts_with?: String;
  mime_type_ends_with?: String;
  mime_type_not_ends_with?: String;
  data?: String;
  data_not?: String;
  data_in?: String[] | String;
  data_not_in?: String[] | String;
  data_lt?: String;
  data_lte?: String;
  data_gt?: String;
  data_gte?: String;
  data_contains?: String;
  data_not_contains?: String;
  data_starts_with?: String;
  data_not_starts_with?: String;
  data_ends_with?: String;
  data_not_ends_with?: String;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: ContentWhereInput[] | ContentWhereInput;
  OR?: ContentWhereInput[] | ContentWhereInput;
  NOT?: ContentWhereInput[] | ContentWhereInput;
}

export interface CheckWorthyWhereInput {
  call?: Boolean;
  call_not?: Boolean;
  check_worthiness?: Float;
  check_worthiness_not?: Float;
  check_worthiness_in?: Float[] | Float;
  check_worthiness_not_in?: Float[] | Float;
  check_worthiness_lt?: Float;
  check_worthiness_lte?: Float;
  check_worthiness_gt?: Float;
  check_worthiness_gte?: Float;
  support_every?: AnnotationWhereInput;
  support_some?: AnnotationWhereInput;
  support_none?: AnnotationWhereInput;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: CheckWorthyWhereInput[] | CheckWorthyWhereInput;
  OR?: CheckWorthyWhereInput[] | CheckWorthyWhereInput;
  NOT?: CheckWorthyWhereInput[] | CheckWorthyWhereInput;
}

export type ClaimWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ClaimWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  claim_text?: String;
  claim_text_not?: String;
  claim_text_in?: String[] | String;
  claim_text_not_in?: String[] | String;
  claim_text_lt?: String;
  claim_text_lte?: String;
  claim_text_gt?: String;
  claim_text_gte?: String;
  claim_text_contains?: String;
  claim_text_not_contains?: String;
  claim_text_starts_with?: String;
  claim_text_not_starts_with?: String;
  claim_text_ends_with?: String;
  claim_text_not_ends_with?: String;
  claim_timestamp?: DateTimeInput;
  claim_timestamp_not?: DateTimeInput;
  claim_timestamp_in?: DateTimeInput[] | DateTimeInput;
  claim_timestamp_not_in?: DateTimeInput[] | DateTimeInput;
  claim_timestamp_lt?: DateTimeInput;
  claim_timestamp_lte?: DateTimeInput;
  claim_timestamp_gt?: DateTimeInput;
  claim_timestamp_gte?: DateTimeInput;
  support?: ClaimSupportWhereInput;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: ClaimWhereInput[] | ClaimWhereInput;
  OR?: ClaimWhereInput[] | ClaimWhereInput;
  NOT?: ClaimWhereInput[] | ClaimWhereInput;
}

export interface ClaimSupportWhereInput {
  attributions_every?: AttributionWhereInput;
  attributions_some?: AttributionWhereInput;
  attributions_none?: AttributionWhereInput;
  AND?: ClaimSupportWhereInput[] | ClaimSupportWhereInput;
  OR?: ClaimSupportWhereInput[] | ClaimSupportWhereInput;
  NOT?: ClaimSupportWhereInput[] | ClaimSupportWhereInput;
}

export interface ResponseWhereInput {
  check_worthy?: CheckWorthyWhereInput;
  truth_rating?: TruthRatingWhereInput;
  annotation_every?: AnnotationWhereInput;
  annotation_some?: AnnotationWhereInput;
  annotation_none?: AnnotationWhereInput;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: ResponseWhereInput[] | ResponseWhereInput;
  OR?: ResponseWhereInput[] | ResponseWhereInput;
  NOT?: ResponseWhereInput[] | ResponseWhereInput;
}

export interface TruthRatingWhereInput {
  call?: Boolean;
  call_not?: Boolean;
  truthiness?: Float;
  truthiness_not?: Float;
  truthiness_in?: Float[] | Float;
  truthiness_not_in?: Float[] | Float;
  truthiness_lt?: Float;
  truthiness_lte?: Float;
  truthiness_gt?: Float;
  truthiness_gte?: Float;
  support_every?: AnnotationWhereInput;
  support_some?: AnnotationWhereInput;
  support_none?: AnnotationWhereInput;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  submitted_by?: AgentWhereInput;
  AND?: TruthRatingWhereInput[] | TruthRatingWhereInput;
  OR?: TruthRatingWhereInput[] | TruthRatingWhereInput;
  NOT?: TruthRatingWhereInput[] | TruthRatingWhereInput;
}

export interface AgentCreateInput {
  email: String;
  password: String;
  name?: String;
}

export interface AgentUpdateInput {
  email?: String;
  password?: String;
  name?: String;
}

export interface AgentUpdateManyMutationInput {
  email?: String;
  password?: String;
  name?: String;
}

export interface AnnotationCreateInput {
  source_url?: String;
  data?: String;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface AgentCreateOneInput {
  create?: AgentCreateInput;
  connect?: AgentWhereUniqueInput;
}

export interface AnnotationUpdateManyMutationInput {
  source_url?: String;
  data?: String;
  created?: DateTimeInput;
}

export interface AttributionCreateInput {
  source_url?: String;
  snapshot?: ContentCreateOneInput;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface ContentCreateOneInput {
  create?: ContentCreateInput;
}

export interface ContentCreateInput {
  hash?: String;
  mime_type?: String;
  data?: String;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface AttributionUpdateManyMutationInput {
  source_url?: String;
  created?: DateTimeInput;
}

export interface CheckWorthyCreateInput {
  call?: Boolean;
  check_worthiness?: Float;
  support?: AnnotationCreateManyInput;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface AnnotationCreateManyInput {
  create?: AnnotationCreateInput[] | AnnotationCreateInput;
}

export interface CheckWorthyUpdateManyMutationInput {
  call?: Boolean;
  check_worthiness?: Float;
  created?: DateTimeInput;
}

export interface ClaimCreateInput {
  claim_text: String;
  claim_timestamp: DateTimeInput;
  support?: ClaimSupportCreateOneInput;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface ClaimSupportCreateOneInput {
  create?: ClaimSupportCreateInput;
}

export interface ClaimSupportCreateInput {
  attributions?: AttributionCreateManyInput;
}

export interface AttributionCreateManyInput {
  create?: AttributionCreateInput[] | AttributionCreateInput;
}

export interface ClaimUpdateInput {
  claim_text?: String;
  claim_timestamp?: DateTimeInput;
  support?: ClaimSupportUpdateOneInput;
  created?: DateTimeInput;
  submitted_by?: AgentUpdateOneRequiredInput;
}

export interface ClaimSupportUpdateOneInput {
  create?: ClaimSupportCreateInput;
  update?: ClaimSupportUpdateDataInput;
  upsert?: ClaimSupportUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface ClaimSupportUpdateDataInput {
  attributions?: AttributionUpdateManyInput;
}

export interface AttributionUpdateManyInput {
  create?: AttributionCreateInput[] | AttributionCreateInput;
  deleteMany?: AttributionScalarWhereInput[] | AttributionScalarWhereInput;
  updateMany?:
    | AttributionUpdateManyWithWhereNestedInput[]
    | AttributionUpdateManyWithWhereNestedInput;
}

export interface AttributionScalarWhereInput {
  source_url?: String;
  source_url_not?: String;
  source_url_in?: String[] | String;
  source_url_not_in?: String[] | String;
  source_url_lt?: String;
  source_url_lte?: String;
  source_url_gt?: String;
  source_url_gte?: String;
  source_url_contains?: String;
  source_url_not_contains?: String;
  source_url_starts_with?: String;
  source_url_not_starts_with?: String;
  source_url_ends_with?: String;
  source_url_not_ends_with?: String;
  created?: DateTimeInput;
  created_not?: DateTimeInput;
  created_in?: DateTimeInput[] | DateTimeInput;
  created_not_in?: DateTimeInput[] | DateTimeInput;
  created_lt?: DateTimeInput;
  created_lte?: DateTimeInput;
  created_gt?: DateTimeInput;
  created_gte?: DateTimeInput;
  AND?: AttributionScalarWhereInput[] | AttributionScalarWhereInput;
  OR?: AttributionScalarWhereInput[] | AttributionScalarWhereInput;
  NOT?: AttributionScalarWhereInput[] | AttributionScalarWhereInput;
}

export interface AttributionUpdateManyWithWhereNestedInput {
  where: AttributionScalarWhereInput;
  data: AttributionUpdateManyDataInput;
}

export interface AttributionUpdateManyDataInput {
  source_url?: String;
  created?: DateTimeInput;
}

export interface ClaimSupportUpsertNestedInput {
  update: ClaimSupportUpdateDataInput;
  create: ClaimSupportCreateInput;
}

export interface AgentUpdateOneRequiredInput {
  create?: AgentCreateInput;
  update?: AgentUpdateDataInput;
  upsert?: AgentUpsertNestedInput;
  connect?: AgentWhereUniqueInput;
}

export interface AgentUpdateDataInput {
  email?: String;
  password?: String;
  name?: String;
}

export interface AgentUpsertNestedInput {
  update: AgentUpdateDataInput;
  create: AgentCreateInput;
}

export interface ClaimUpdateManyMutationInput {
  claim_text?: String;
  claim_timestamp?: DateTimeInput;
  created?: DateTimeInput;
}

export interface ContentUpdateManyMutationInput {
  hash?: String;
  mime_type?: String;
  data?: String;
  created?: DateTimeInput;
}

export interface ResponseCreateInput {
  check_worthy?: CheckWorthyCreateOneInput;
  truth_rating?: TruthRatingCreateOneInput;
  annotation?: AnnotationCreateManyInput;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface CheckWorthyCreateOneInput {
  create?: CheckWorthyCreateInput;
}

export interface TruthRatingCreateOneInput {
  create?: TruthRatingCreateInput;
}

export interface TruthRatingCreateInput {
  call?: Boolean;
  truthiness?: Float;
  support?: AnnotationCreateManyInput;
  created: DateTimeInput;
  submitted_by: AgentCreateOneInput;
}

export interface ResponseUpdateManyMutationInput {
  created?: DateTimeInput;
}

export interface TruthRatingUpdateManyMutationInput {
  call?: Boolean;
  truthiness?: Float;
  created?: DateTimeInput;
}

export interface AgentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AgentWhereInput;
  AND?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
  OR?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
  NOT?: AgentSubscriptionWhereInput[] | AgentSubscriptionWhereInput;
}

export interface AnnotationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AnnotationWhereInput;
  AND?: AnnotationSubscriptionWhereInput[] | AnnotationSubscriptionWhereInput;
  OR?: AnnotationSubscriptionWhereInput[] | AnnotationSubscriptionWhereInput;
  NOT?: AnnotationSubscriptionWhereInput[] | AnnotationSubscriptionWhereInput;
}

export interface AttributionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttributionWhereInput;
  AND?: AttributionSubscriptionWhereInput[] | AttributionSubscriptionWhereInput;
  OR?: AttributionSubscriptionWhereInput[] | AttributionSubscriptionWhereInput;
  NOT?: AttributionSubscriptionWhereInput[] | AttributionSubscriptionWhereInput;
}

export interface CheckWorthySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CheckWorthyWhereInput;
  AND?: CheckWorthySubscriptionWhereInput[] | CheckWorthySubscriptionWhereInput;
  OR?: CheckWorthySubscriptionWhereInput[] | CheckWorthySubscriptionWhereInput;
  NOT?: CheckWorthySubscriptionWhereInput[] | CheckWorthySubscriptionWhereInput;
}

export interface ClaimSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClaimWhereInput;
  AND?: ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput;
  OR?: ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput;
  NOT?: ClaimSubscriptionWhereInput[] | ClaimSubscriptionWhereInput;
}

export interface ClaimSupportSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClaimSupportWhereInput;
  AND?:
    | ClaimSupportSubscriptionWhereInput[]
    | ClaimSupportSubscriptionWhereInput;
  OR?:
    | ClaimSupportSubscriptionWhereInput[]
    | ClaimSupportSubscriptionWhereInput;
  NOT?:
    | ClaimSupportSubscriptionWhereInput[]
    | ClaimSupportSubscriptionWhereInput;
}

export interface ContentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContentWhereInput;
  AND?: ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput;
  OR?: ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput;
  NOT?: ContentSubscriptionWhereInput[] | ContentSubscriptionWhereInput;
}

export interface ResponseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResponseWhereInput;
  AND?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
  OR?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
  NOT?: ResponseSubscriptionWhereInput[] | ResponseSubscriptionWhereInput;
}

export interface TruthRatingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TruthRatingWhereInput;
  AND?: TruthRatingSubscriptionWhereInput[] | TruthRatingSubscriptionWhereInput;
  OR?: TruthRatingSubscriptionWhereInput[] | TruthRatingSubscriptionWhereInput;
  NOT?: TruthRatingSubscriptionWhereInput[] | TruthRatingSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Agent {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
}

export interface AgentPromise extends Promise<Agent>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AgentSubscription
  extends Promise<AsyncIterator<Agent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AgentConnection {
  pageInfo: PageInfo;
  edges: AgentEdge[];
}

export interface AgentConnectionPromise
  extends Promise<AgentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AgentEdge>>() => T;
  aggregate: <T = AggregateAgentPromise>() => T;
}

export interface AgentConnectionSubscription
  extends Promise<AsyncIterator<AgentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AgentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAgentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AgentEdge {
  node: Agent;
  cursor: String;
}

export interface AgentEdgePromise extends Promise<AgentEdge>, Fragmentable {
  node: <T = AgentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AgentEdgeSubscription
  extends Promise<AsyncIterator<AgentEdge>>,
    Fragmentable {
  node: <T = AgentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAgent {
  count: Int;
}

export interface AggregateAgentPromise
  extends Promise<AggregateAgent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAgentSubscription
  extends Promise<AsyncIterator<AggregateAgent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Annotation {
  source_url?: String;
  data?: String;
  created: DateTimeOutput;
}

export interface AnnotationPromise extends Promise<Annotation>, Fragmentable {
  source_url: () => Promise<String>;
  data: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface AnnotationSubscription
  extends Promise<AsyncIterator<Annotation>>,
    Fragmentable {
  source_url: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface AnnotationConnection {
  pageInfo: PageInfo;
  edges: AnnotationEdge[];
}

export interface AnnotationConnectionPromise
  extends Promise<AnnotationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnnotationEdge>>() => T;
  aggregate: <T = AggregateAnnotationPromise>() => T;
}

export interface AnnotationConnectionSubscription
  extends Promise<AsyncIterator<AnnotationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnnotationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnnotationSubscription>() => T;
}

export interface AnnotationEdge {
  node: Annotation;
  cursor: String;
}

export interface AnnotationEdgePromise
  extends Promise<AnnotationEdge>,
    Fragmentable {
  node: <T = AnnotationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnnotationEdgeSubscription
  extends Promise<AsyncIterator<AnnotationEdge>>,
    Fragmentable {
  node: <T = AnnotationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAnnotation {
  count: Int;
}

export interface AggregateAnnotationPromise
  extends Promise<AggregateAnnotation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnnotationSubscription
  extends Promise<AsyncIterator<AggregateAnnotation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Attribution {
  source_url?: String;
  created: DateTimeOutput;
}

export interface AttributionPromise extends Promise<Attribution>, Fragmentable {
  source_url: () => Promise<String>;
  snapshot: <T = ContentPromise>() => T;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface AttributionSubscription
  extends Promise<AsyncIterator<Attribution>>,
    Fragmentable {
  source_url: () => Promise<AsyncIterator<String>>;
  snapshot: <T = ContentSubscription>() => T;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface Content {
  hash?: String;
  mime_type?: String;
  data?: String;
  created: DateTimeOutput;
}

export interface ContentPromise extends Promise<Content>, Fragmentable {
  hash: () => Promise<String>;
  mime_type: () => Promise<String>;
  data: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface ContentSubscription
  extends Promise<AsyncIterator<Content>>,
    Fragmentable {
  hash: () => Promise<AsyncIterator<String>>;
  mime_type: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface AttributionConnection {
  pageInfo: PageInfo;
  edges: AttributionEdge[];
}

export interface AttributionConnectionPromise
  extends Promise<AttributionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttributionEdge>>() => T;
  aggregate: <T = AggregateAttributionPromise>() => T;
}

export interface AttributionConnectionSubscription
  extends Promise<AsyncIterator<AttributionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttributionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttributionSubscription>() => T;
}

export interface AttributionEdge {
  node: Attribution;
  cursor: String;
}

export interface AttributionEdgePromise
  extends Promise<AttributionEdge>,
    Fragmentable {
  node: <T = AttributionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttributionEdgeSubscription
  extends Promise<AsyncIterator<AttributionEdge>>,
    Fragmentable {
  node: <T = AttributionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttribution {
  count: Int;
}

export interface AggregateAttributionPromise
  extends Promise<AggregateAttribution>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttributionSubscription
  extends Promise<AsyncIterator<AggregateAttribution>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CheckWorthy {
  call: Boolean;
  check_worthiness?: Float;
  created: DateTimeOutput;
}

export interface CheckWorthyPromise extends Promise<CheckWorthy>, Fragmentable {
  call: () => Promise<Boolean>;
  check_worthiness: () => Promise<Float>;
  support: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface CheckWorthySubscription
  extends Promise<AsyncIterator<CheckWorthy>>,
    Fragmentable {
  call: () => Promise<AsyncIterator<Boolean>>;
  check_worthiness: () => Promise<AsyncIterator<Float>>;
  support: <T = Promise<AsyncIterator<AnnotationSubscription>>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface CheckWorthyConnection {
  pageInfo: PageInfo;
  edges: CheckWorthyEdge[];
}

export interface CheckWorthyConnectionPromise
  extends Promise<CheckWorthyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CheckWorthyEdge>>() => T;
  aggregate: <T = AggregateCheckWorthyPromise>() => T;
}

export interface CheckWorthyConnectionSubscription
  extends Promise<AsyncIterator<CheckWorthyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CheckWorthyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCheckWorthySubscription>() => T;
}

export interface CheckWorthyEdge {
  node: CheckWorthy;
  cursor: String;
}

export interface CheckWorthyEdgePromise
  extends Promise<CheckWorthyEdge>,
    Fragmentable {
  node: <T = CheckWorthyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CheckWorthyEdgeSubscription
  extends Promise<AsyncIterator<CheckWorthyEdge>>,
    Fragmentable {
  node: <T = CheckWorthySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCheckWorthy {
  count: Int;
}

export interface AggregateCheckWorthyPromise
  extends Promise<AggregateCheckWorthy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCheckWorthySubscription
  extends Promise<AsyncIterator<AggregateCheckWorthy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Claim {
  id: ID_Output;
  claim_text: String;
  claim_timestamp: DateTimeOutput;
  created: DateTimeOutput;
}

export interface ClaimPromise extends Promise<Claim>, Fragmentable {
  id: () => Promise<ID_Output>;
  claim_text: () => Promise<String>;
  claim_timestamp: () => Promise<DateTimeOutput>;
  support: <T = ClaimSupportPromise>() => T;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface ClaimSubscription
  extends Promise<AsyncIterator<Claim>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  claim_text: () => Promise<AsyncIterator<String>>;
  claim_timestamp: () => Promise<AsyncIterator<DateTimeOutput>>;
  support: <T = ClaimSupportSubscription>() => T;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface ClaimSupport {}

export interface ClaimSupportPromise
  extends Promise<ClaimSupport>,
    Fragmentable {
  attributions: <T = FragmentableArray<Attribution>>(args?: {
    where?: AttributionWhereInput;
    orderBy?: AttributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClaimSupportSubscription
  extends Promise<AsyncIterator<ClaimSupport>>,
    Fragmentable {
  attributions: <T = Promise<AsyncIterator<AttributionSubscription>>>(args?: {
    where?: AttributionWhereInput;
    orderBy?: AttributionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ClaimConnection {
  pageInfo: PageInfo;
  edges: ClaimEdge[];
}

export interface ClaimConnectionPromise
  extends Promise<ClaimConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClaimEdge>>() => T;
  aggregate: <T = AggregateClaimPromise>() => T;
}

export interface ClaimConnectionSubscription
  extends Promise<AsyncIterator<ClaimConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClaimEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClaimSubscription>() => T;
}

export interface ClaimEdge {
  node: Claim;
  cursor: String;
}

export interface ClaimEdgePromise extends Promise<ClaimEdge>, Fragmentable {
  node: <T = ClaimPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClaimEdgeSubscription
  extends Promise<AsyncIterator<ClaimEdge>>,
    Fragmentable {
  node: <T = ClaimSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClaim {
  count: Int;
}

export interface AggregateClaimPromise
  extends Promise<AggregateClaim>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClaimSubscription
  extends Promise<AsyncIterator<AggregateClaim>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClaimSupportConnection {}

export interface ClaimSupportConnectionPromise
  extends Promise<ClaimSupportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClaimSupportEdge>>() => T;
  aggregate: <T = AggregateClaimSupportPromise>() => T;
}

export interface ClaimSupportConnectionSubscription
  extends Promise<AsyncIterator<ClaimSupportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClaimSupportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClaimSupportSubscription>() => T;
}

export interface ClaimSupportEdge {
  node: ClaimSupport;
  cursor: String;
}

export interface ClaimSupportEdgePromise
  extends Promise<ClaimSupportEdge>,
    Fragmentable {
  node: <T = ClaimSupportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClaimSupportEdgeSubscription
  extends Promise<AsyncIterator<ClaimSupportEdge>>,
    Fragmentable {
  node: <T = ClaimSupportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClaimSupport {
  count: Int;
}

export interface AggregateClaimSupportPromise
  extends Promise<AggregateClaimSupport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClaimSupportSubscription
  extends Promise<AsyncIterator<AggregateClaimSupport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContentConnection {
  pageInfo: PageInfo;
  edges: ContentEdge[];
}

export interface ContentConnectionPromise
  extends Promise<ContentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContentEdge>>() => T;
  aggregate: <T = AggregateContentPromise>() => T;
}

export interface ContentConnectionSubscription
  extends Promise<AsyncIterator<ContentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContentSubscription>() => T;
}

export interface ContentEdge {
  node: Content;
  cursor: String;
}

export interface ContentEdgePromise extends Promise<ContentEdge>, Fragmentable {
  node: <T = ContentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContentEdgeSubscription
  extends Promise<AsyncIterator<ContentEdge>>,
    Fragmentable {
  node: <T = ContentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateContent {
  count: Int;
}

export interface AggregateContentPromise
  extends Promise<AggregateContent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContentSubscription
  extends Promise<AsyncIterator<AggregateContent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Response {
  created: DateTimeOutput;
}

export interface ResponsePromise extends Promise<Response>, Fragmentable {
  check_worthy: <T = CheckWorthyPromise>() => T;
  truth_rating: <T = TruthRatingPromise>() => T;
  annotation: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface ResponseSubscription
  extends Promise<AsyncIterator<Response>>,
    Fragmentable {
  check_worthy: <T = CheckWorthySubscription>() => T;
  truth_rating: <T = TruthRatingSubscription>() => T;
  annotation: <T = Promise<AsyncIterator<AnnotationSubscription>>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface TruthRating {
  call: Boolean;
  truthiness?: Float;
  created: DateTimeOutput;
}

export interface TruthRatingPromise extends Promise<TruthRating>, Fragmentable {
  call: () => Promise<Boolean>;
  truthiness: () => Promise<Float>;
  support: <T = FragmentableArray<Annotation>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<DateTimeOutput>;
  submitted_by: <T = AgentPromise>() => T;
}

export interface TruthRatingSubscription
  extends Promise<AsyncIterator<TruthRating>>,
    Fragmentable {
  call: () => Promise<AsyncIterator<Boolean>>;
  truthiness: () => Promise<AsyncIterator<Float>>;
  support: <T = Promise<AsyncIterator<AnnotationSubscription>>>(args?: {
    where?: AnnotationWhereInput;
    orderBy?: AnnotationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  submitted_by: <T = AgentSubscription>() => T;
}

export interface ResponseConnection {
  pageInfo: PageInfo;
  edges: ResponseEdge[];
}

export interface ResponseConnectionPromise
  extends Promise<ResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResponseEdge>>() => T;
  aggregate: <T = AggregateResponsePromise>() => T;
}

export interface ResponseConnectionSubscription
  extends Promise<AsyncIterator<ResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResponseSubscription>() => T;
}

export interface ResponseEdge {
  node: Response;
  cursor: String;
}

export interface ResponseEdgePromise
  extends Promise<ResponseEdge>,
    Fragmentable {
  node: <T = ResponsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResponseEdgeSubscription
  extends Promise<AsyncIterator<ResponseEdge>>,
    Fragmentable {
  node: <T = ResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResponse {
  count: Int;
}

export interface AggregateResponsePromise
  extends Promise<AggregateResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResponseSubscription
  extends Promise<AsyncIterator<AggregateResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TruthRatingConnection {
  pageInfo: PageInfo;
  edges: TruthRatingEdge[];
}

export interface TruthRatingConnectionPromise
  extends Promise<TruthRatingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TruthRatingEdge>>() => T;
  aggregate: <T = AggregateTruthRatingPromise>() => T;
}

export interface TruthRatingConnectionSubscription
  extends Promise<AsyncIterator<TruthRatingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TruthRatingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTruthRatingSubscription>() => T;
}

export interface TruthRatingEdge {
  node: TruthRating;
  cursor: String;
}

export interface TruthRatingEdgePromise
  extends Promise<TruthRatingEdge>,
    Fragmentable {
  node: <T = TruthRatingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TruthRatingEdgeSubscription
  extends Promise<AsyncIterator<TruthRatingEdge>>,
    Fragmentable {
  node: <T = TruthRatingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTruthRating {
  count: Int;
}

export interface AggregateTruthRatingPromise
  extends Promise<AggregateTruthRating>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTruthRatingSubscription
  extends Promise<AsyncIterator<AggregateTruthRating>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AgentSubscriptionPayload {
  mutation: MutationType;
  node: Agent;
  updatedFields: String[];
  previousValues: AgentPreviousValues;
}

export interface AgentSubscriptionPayloadPromise
  extends Promise<AgentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AgentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AgentPreviousValuesPromise>() => T;
}

export interface AgentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AgentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AgentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AgentPreviousValuesSubscription>() => T;
}

export interface AgentPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  name?: String;
}

export interface AgentPreviousValuesPromise
  extends Promise<AgentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AgentPreviousValuesSubscription
  extends Promise<AsyncIterator<AgentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AnnotationSubscriptionPayload {
  mutation: MutationType;
  node: Annotation;
  updatedFields: String[];
  previousValues: AnnotationPreviousValues;
}

export interface AnnotationSubscriptionPayloadPromise
  extends Promise<AnnotationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnnotationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnnotationPreviousValuesPromise>() => T;
}

export interface AnnotationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnnotationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnnotationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnnotationPreviousValuesSubscription>() => T;
}

export interface AnnotationPreviousValues {
  source_url?: String;
  data?: String;
  created: DateTimeOutput;
}

export interface AnnotationPreviousValuesPromise
  extends Promise<AnnotationPreviousValues>,
    Fragmentable {
  source_url: () => Promise<String>;
  data: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
}

export interface AnnotationPreviousValuesSubscription
  extends Promise<AsyncIterator<AnnotationPreviousValues>>,
    Fragmentable {
  source_url: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AttributionSubscriptionPayload {
  mutation: MutationType;
  node: Attribution;
  updatedFields: String[];
  previousValues: AttributionPreviousValues;
}

export interface AttributionSubscriptionPayloadPromise
  extends Promise<AttributionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttributionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttributionPreviousValuesPromise>() => T;
}

export interface AttributionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttributionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttributionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttributionPreviousValuesSubscription>() => T;
}

export interface AttributionPreviousValues {
  source_url?: String;
  created: DateTimeOutput;
}

export interface AttributionPreviousValuesPromise
  extends Promise<AttributionPreviousValues>,
    Fragmentable {
  source_url: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
}

export interface AttributionPreviousValuesSubscription
  extends Promise<AsyncIterator<AttributionPreviousValues>>,
    Fragmentable {
  source_url: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CheckWorthySubscriptionPayload {
  mutation: MutationType;
  node: CheckWorthy;
  updatedFields: String[];
  previousValues: CheckWorthyPreviousValues;
}

export interface CheckWorthySubscriptionPayloadPromise
  extends Promise<CheckWorthySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CheckWorthyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CheckWorthyPreviousValuesPromise>() => T;
}

export interface CheckWorthySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CheckWorthySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CheckWorthySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CheckWorthyPreviousValuesSubscription>() => T;
}

export interface CheckWorthyPreviousValues {
  call: Boolean;
  check_worthiness?: Float;
  created: DateTimeOutput;
}

export interface CheckWorthyPreviousValuesPromise
  extends Promise<CheckWorthyPreviousValues>,
    Fragmentable {
  call: () => Promise<Boolean>;
  check_worthiness: () => Promise<Float>;
  created: () => Promise<DateTimeOutput>;
}

export interface CheckWorthyPreviousValuesSubscription
  extends Promise<AsyncIterator<CheckWorthyPreviousValues>>,
    Fragmentable {
  call: () => Promise<AsyncIterator<Boolean>>;
  check_worthiness: () => Promise<AsyncIterator<Float>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClaimSubscriptionPayload {
  mutation: MutationType;
  node: Claim;
  updatedFields: String[];
  previousValues: ClaimPreviousValues;
}

export interface ClaimSubscriptionPayloadPromise
  extends Promise<ClaimSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClaimPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClaimPreviousValuesPromise>() => T;
}

export interface ClaimSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClaimSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClaimSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClaimPreviousValuesSubscription>() => T;
}

export interface ClaimPreviousValues {
  id: ID_Output;
  claim_text: String;
  claim_timestamp: DateTimeOutput;
  created: DateTimeOutput;
}

export interface ClaimPreviousValuesPromise
  extends Promise<ClaimPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  claim_text: () => Promise<String>;
  claim_timestamp: () => Promise<DateTimeOutput>;
  created: () => Promise<DateTimeOutput>;
}

export interface ClaimPreviousValuesSubscription
  extends Promise<AsyncIterator<ClaimPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  claim_text: () => Promise<AsyncIterator<String>>;
  claim_timestamp: () => Promise<AsyncIterator<DateTimeOutput>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ClaimSupportSubscriptionPayload {
  mutation: MutationType;
  node: ClaimSupport;
  updatedFields: String[];
}

export interface ClaimSupportSubscriptionPayloadPromise
  extends Promise<ClaimSupportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClaimSupportPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface ClaimSupportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClaimSupportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClaimSupportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface ContentSubscriptionPayload {
  mutation: MutationType;
  node: Content;
  updatedFields: String[];
  previousValues: ContentPreviousValues;
}

export interface ContentSubscriptionPayloadPromise
  extends Promise<ContentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContentPreviousValuesPromise>() => T;
}

export interface ContentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContentPreviousValuesSubscription>() => T;
}

export interface ContentPreviousValues {
  hash?: String;
  mime_type?: String;
  data?: String;
  created: DateTimeOutput;
}

export interface ContentPreviousValuesPromise
  extends Promise<ContentPreviousValues>,
    Fragmentable {
  hash: () => Promise<String>;
  mime_type: () => Promise<String>;
  data: () => Promise<String>;
  created: () => Promise<DateTimeOutput>;
}

export interface ContentPreviousValuesSubscription
  extends Promise<AsyncIterator<ContentPreviousValues>>,
    Fragmentable {
  hash: () => Promise<AsyncIterator<String>>;
  mime_type: () => Promise<AsyncIterator<String>>;
  data: () => Promise<AsyncIterator<String>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ResponseSubscriptionPayload {
  mutation: MutationType;
  node: Response;
  updatedFields: String[];
  previousValues: ResponsePreviousValues;
}

export interface ResponseSubscriptionPayloadPromise
  extends Promise<ResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResponsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResponsePreviousValuesPromise>() => T;
}

export interface ResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResponsePreviousValuesSubscription>() => T;
}

export interface ResponsePreviousValues {
  created: DateTimeOutput;
}

export interface ResponsePreviousValuesPromise
  extends Promise<ResponsePreviousValues>,
    Fragmentable {
  created: () => Promise<DateTimeOutput>;
}

export interface ResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<ResponsePreviousValues>>,
    Fragmentable {
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TruthRatingSubscriptionPayload {
  mutation: MutationType;
  node: TruthRating;
  updatedFields: String[];
  previousValues: TruthRatingPreviousValues;
}

export interface TruthRatingSubscriptionPayloadPromise
  extends Promise<TruthRatingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TruthRatingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TruthRatingPreviousValuesPromise>() => T;
}

export interface TruthRatingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TruthRatingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TruthRatingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TruthRatingPreviousValuesSubscription>() => T;
}

export interface TruthRatingPreviousValues {
  call: Boolean;
  truthiness?: Float;
  created: DateTimeOutput;
}

export interface TruthRatingPreviousValuesPromise
  extends Promise<TruthRatingPreviousValues>,
    Fragmentable {
  call: () => Promise<Boolean>;
  truthiness: () => Promise<Float>;
  created: () => Promise<DateTimeOutput>;
}

export interface TruthRatingPreviousValuesSubscription
  extends Promise<AsyncIterator<TruthRatingPreviousValues>>,
    Fragmentable {
  call: () => Promise<AsyncIterator<Boolean>>;
  truthiness: () => Promise<AsyncIterator<Float>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Agent",
    embedded: false
  },
  {
    name: "Annotation",
    embedded: false
  },
  {
    name: "Attribution",
    embedded: false
  },
  {
    name: "CheckWorthy",
    embedded: false
  },
  {
    name: "Claim",
    embedded: false
  },
  {
    name: "ClaimSupport",
    embedded: false
  },
  {
    name: "Content",
    embedded: false
  },
  {
    name: "Response",
    embedded: false
  },
  {
    name: "TruthRating",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
